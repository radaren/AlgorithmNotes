2016#4+2



# 第一场打铁

五个小时一题没有过的感觉还是很不好受的.

晚上思考了很久人生.觉得大一还是努力去见见世面吧.

但是大二的两个队友却都没空参赛了.sigh..真的有一些莫名的绝望.

## 第一题 an = 2an-1 - 3an-2 + 1

给出a0,a1求第n个数

当时看到题就很兴奋地写起了矩阵快速幂.T了之后找公式,莫名继续T到最后.

赛后看诗源用矩阵快速幂过的,梓华用快速幂过的.......绝望- -



思路是找到高中数列公式,然后快速幂

## 快速幂写烂后找的歪门邪道

1. 存前面200w的2^n,如果快速幂遇到直接查表
2. 2的快速幂位运算

## 总结

1. 一段代码写烂一个小时后就得有重写的打算,不要老是"调"评测系统
2. 一个代码超时如果尚有可回忆的方法,那么久一定要坚持复杂度.超时可能是写烂了而不是复杂度太高



## 第二题 最小哈密尔顿

给出一个Wn的圈(见离散书上的举例...)每次修改一条边,求每次修改后的最小哈密尔顿回路



这题是思路不对.

一开始map存的东西不多,后来用优先队列做,每次把修改的边和旁边两条都丢到队列里面,维护版本信息.但是这样的话旧版本可能会覆盖新版本然后就**忘记pop**了...

对于一个区间的动态维护首先应该想到线段树.

- 线段树和优先队列的区别.
- 线段树是每次查询的时候更新,优先队列对于版本信息会较为混淆(不能及时剔除旧版本)

赛后诗源说map设计好一些也能过,

梓华维护了一颗二叉树+桶排..不明觉厉XD



另外最后一题听说也能用线段树来过,就是一个动态的归并?



# 第二场迷之两题

一上手看最后一题..写了半小时发现看错题了........

但是还算是捡回了昨天的运气XD

## 第一题 动归+剪枝

给一个10w长的(0,10w)的递增序列,求一个最长子序列

要求: gcd(bn,bn-1) > 1



过的太迷..不过也算走了正确的道路,但还是先讲故事吧..

打张素数表后,每读入一个元素

质因数分解,更新一个,dp值,定义为到第n个数的最长子序列,然后莫名WA到第一个数据...然后开始了谜一样的对OJ测试…重复1遍过了两组数据后就来劲了..看了眼时间直接循环200遍过到第4组数据,然后跳到800遍TLE,调回500遍第五组数据T,做了一些剪枝后WA,再用list优化了"下一个数"400第六组数据TLE,然后再优化365遍第八组数据了...

突然想到了第一天的悲伤..然后放弃这样瞎搞了...观察代码结构继续剪枝



1. 开一个c[maxn]数组记录每个数的最大质因数位置,然后分解的时候只需要分解到那就可以了.
2. 开一个a[maxn]数组,每读入一个数更新一次它所有质因数dp = maxdp[因数] + 1;

两个优化后0.368秒过了

4+2第一题..兴奋的打开了第二题



## 第二题 撒点算面积

第一遍看完题目居然懒得做...

> 给出两个矩形两个圆,求被矩形覆盖然而不被圆覆盖的面积

第二遍看完题目就开始后悔...这么水.......特别发现数据范围是(0,10)....

然后就开始了撒点打发…两个for循环(double x = 0;x < 10;x += 0.001)枚举其中的点统计符合要求的点数/100000就理论可以了,,然而居然WA...滚去再看题

发现是图像range是(0,10),怪自己眼瞎..居然看成了坐标range然后重新改了下枚举..就是第一个矩形统计不在圆里面的点,第二个统计不在圆而且不在第一个里面的点..过了...



赛后得知..坐标range就是(0,10),也就是说一开始的算法又写烂了..



## 后面两道没过的题

### 第三题,求每次删回文串最少删多少次.

记忆化搜索DP状态转移方程写崩了...

```c++
DP(i,j) 
=  0 //i <= j
=  1 //i == j || i + 1 == j && a[i] == a[j]
=  DP(i+1,j-1)//a[i] == a[j]
=  min(DP(i+1,j) , DP(i,j+1) )+1 // a[i] != a[j]这里错了....
```

### 第四题,给出四堆石子最后拿走的输

最基本的NIM博弈都忘了也是迷...

题目是求最多四堆有那么多的时候,期中包含可赢情况的和



1. NIM博弈赢的方式是所有异或为0
2. 统计四堆不如统计两堆.然后枚举后面两堆和前面两堆异或一样就可以了..



BTW.今天晚霞挺美的.

![](/img/sum.jpeg)







